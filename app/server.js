const express=require("express"),fs=require("fs").promises,path=require("path"),multer=require("multer"),mm=require("music-metadata"),app=express(),PORT=3e3;app.use(express.json());const musicDirectory=path.join(__dirname,"music"),playlistsFilePath=path.join(__dirname,"playlists.json"),coversDirectory=path.join(__dirname,"public/covers");let libraryCache=[];async function scanLibrary(){console.log("Starting library scan...");try{await fs.mkdir(coversDirectory,{recursive:!0});const files=await fs.readdir(musicDirectory);const audioFiles=files.filter(file=>file.match(/\.(mp3|wav|ogg|flac)$/i));let processedSongs=await Promise.all(audioFiles.map(async file=>{try{const filePath=path.join(musicDirectory,file);const stats=await fs.stat(filePath);const metadata=await mm.parseFile(filePath);const{title,artist,album}=metadata.common;let coverArtUrl="/covers/default.svg";if(metadata.common.picture?.length>0){const picture=metadata.common.picture[0];const coverPath=path.join(coversDirectory,`${path.parse(file).name}.jpg`);await fs.writeFile(coverPath,picture.data);coverArtUrl=`/covers/${path.parse(file).name}.jpg`}return{filename:file,title:title||path.parse(file).name.replace(/_/g," "),artist:artist||"Unknown Artist",album:album||"Unknown Album",coverArtUrl:coverArtUrl,duration:metadata.format.duration||0,dateAdded:stats.mtime}}catch(error){console.error(`Could not process metadata for ${file}:`,error.message);return null}}));libraryCache=processedSongs.filter(song=>song!==null);const playlists=await readPlaylists();for(const song of libraryCache)song.liked=playlists["Liked Songs"]?.includes(song.filename)??!1;console.log(`Library scan complete. Found ${libraryCache.length} tracks.`)}catch(error){console.error("Error scanning library:",error)}}const readPlaylists=async()=>{try{const data=await fs.readFile(playlistsFilePath);return JSON.parse(data)}catch(error){return{"Liked Songs":[]}}};const writePlaylists=async playlists=>{await fs.writeFile(playlistsFilePath,JSON.stringify(playlists,null,2))};app.use(express.static("public"));app.get("/api/library",(req,res)=>res.json(libraryCache));app.post("/api/rescan",async(req,res)=>{await scanLibrary();res.status(200).json({message:"Library re-scan complete."})});const upload=multer({dest:musicDirectory}).array("musicFiles",50);app.post("/api/upload",(req,res)=>{upload(req,res,async err=>{if(err){return res.status(400).json({message:err.message})}await Promise.all(req.files.map(file=>fs.rename(file.path,path.join(musicDirectory,file.originalname))));await scanLibrary();res.status(200).json({message:`${req.files.length} file(s) uploaded successfully.`})})});app.get("/api/playlists",async(req,res)=>res.json(await readPlaylists()));app.post("/api/playlists",async(req,res)=>{const{name}=req.body;const playlists=await readPlaylists();if(name&&name!=="Liked Songs"&&!playlists[name]){playlists[name]=[];await writePlaylists(playlists);res.status(201).json({message:`Playlist '${name}' created.`})}else{res.status(400).json({message:"Invalid or duplicate playlist name."})}});app.post("/api/playlists/:name/add-multiple",async(req,res)=>{const{name}=req.params;const{songFilenames}=req.body;const playlists=await readPlaylists();if(!playlists[name]||!Array.isArray(songFilenames)){return res.status(400).json({message:"Invalid request."})}let newSongsAdded=0;songFilenames.forEach(filename=>{if(!playlists[name].includes(filename)){playlists[name].push(filename);newSongsAdded++}});if(newSongsAdded>0){await writePlaylists(playlists)}res.status(200).json({message:`${newSongsAdded} new song(s) added to '${name}'.`})});app.delete("/api/playlists/:name/remove",async(req,res)=>{const{name}=req.params;const{songFilename}=req.body;const playlists=await readPlaylists();if(!playlists[name]||!songFilename){return res.status(400).json({message:"Invalid request."})}const index=playlists[name].indexOf(songFilename);if(index>-1){playlists[name].splice(index,1);await writePlaylists(playlists)}res.status(200).json({message:`Song removed from '${name}'.`})});app.delete("/api/library/delete",async(req,res)=>{const{filenames}=req.body;if(!Array.isArray(filenames)){return res.status(400).json({message:"Invalid request."})}try{const playlists=await readPlaylists();for(const playlistName of Object.keys(playlists)){playlists[playlistName]=playlists[playlistName].filter(song=>!filenames.includes(song))}await writePlaylists(playlists);await Promise.all(filenames.map(async file=>{const musicPath=path.join(musicDirectory,file);const coverPath=path.join(coversDirectory,`${path.parse(file).name}.jpg`);await fs.unlink(musicPath);await fs.unlink(coverPath).catch(()=>{console.log(`No cover art for ${file} to delete.`)})}));await scanLibrary();res.status(200).json({message:`${filenames.length} song(s) deleted.`})}catch(error){console.error("Error deleting files:",error);res.status(500).json({message:"Error deleting files."})}});app.post("/api/like-song",async(req,res)=>{const{songFilename}=req.body;const playlists=await readPlaylists();playlists["Liked Songs"]||(playlists["Liked Songs"]=[]);const index=playlists["Liked Songs"].indexOf(songFilename);if(index>-1){playlists["Liked Songs"].splice(index,1)}else{playlists["Liked Songs"].push(songFilename)}await writePlaylists(playlists);const librarySong=libraryCache.find(s=>s.filename===songFilename);if(librarySong)librarySong.liked=index===-1;res.status(200).json({liked:index===-1})});app.get("/music/:fileName",(req,res)=>{const filePath=path.join(musicDirectory,req.params.fileName);res.sendFile(filePath,err=>{if(err){res.status(404).send("File not found.")}})});app.listen(PORT,()=>{scanLibrary();console.log(`Music app v7.1.0 running on http://localhost:${PORT}`)});
